/**
 * genesis block, 
 * a chain initialization
 * create blocks
 * mine block,
 * solid blockchain, 
 */

/**
     * each block has its own proof. so first genesis block has prevHash  = 0 which meanz its first block in the chain.
     * now each block will have few essential things like
     * 1 block number/index
     * 2 proof
     * 3 prev hash
     * 4 timestamp
     * 5 data
     * anything else can be added there as well.
     * 
     * proof will be generated by mining function
     * 
     */


 /**
     * mining function miners need to run/execute to produce the proof.
     * proof of work is the number which miners need to find to mine the block.
     * by solving a problem by miners. define the problem which is hard to find and easy to verify.
     * _prevProof: is the element of the problem.
     */


const crypto  = require('crypto')


class Blockchain {

    constructor(){
        this.chain = []
        this.createBlock(1,  '0')
    }

    
    createBlock(_proof, _prevHash){
        const block = {
            index: this.chain.length + 1,
            timestamp: Date.now(),
            proof: _proof,
            prevHash: _prevHash,
            
        }

        this.chain.push(block)
        console.log('create block is done.')
        return block
    }

    getPreviousBlock (){
        let lastIndex = this.chain.length-1; 
        return this.chain[lastIndex]
    }

    //start from 1 and find the number which solve the problem    
    //verify the hash. as our problem is just any hash has first 4 characters of 0 then its valid.
    proofOfWork (_prevProof){
       return new Promise((resolved, rejected)=>{
            console.log('starting to find new proof...')
            let new_proof = 1 
            let check_proof = false
            while(!check_proof){
                let proof_value = (new_proof**2 - _prevProof**2).toString()
                let hashOperation = crypto.createHash('sha256').update(proof_value).digest('hex')
                //console.log('hash operation: ', hashOperation)
                if(hashOperation.substring(0, 4) === '0000'){
                    check_proof = true
                }else{
                    new_proof += 1
                }
    
            }
    
            console.log('proof of work is done.')

          return resolved(new_proof)  
        })

    }

    hash (block){
        let encodedBlock = JSON.stringify(block)
        return crypto.createHash('sha256').update(encodedBlock).digest('hex')
    }

    /**
     * check a blockchain is valid or not
     * few things need to check here.
     * 1 check the each block has the correct proof of work
     * 2 check the previous hash of each block matches the previous block hash.
     */

    isChainValid(chain){
     return new Promise((resolved, rejected)=>{
            let prevBlock = chain[0]
            let blockIndex = 1
            while(blockIndex < chain.length){
                let block = chain[blockIndex]
                if(block.prevHash != hash(block) ){
                    return resolved(false)
                }
                let prevProof = prevBlock.proof
                let proof = prevBlock.proof

                let proof_value = (proof**2 - prevProof**2).toString()
                let hashOperation = crypto.createHash('sha256').update(proof_value).digest('hex')
                if(hashOperation.subString(0, 3) !== '0000'){
                    return resolved(false)
                }

                prevBlock = block
                blockIndex += 1
            }
            //finally return true as above while loop is succeeded.
            return resolved(true)

        })
        
     
    }


}

module.exports = Blockchain